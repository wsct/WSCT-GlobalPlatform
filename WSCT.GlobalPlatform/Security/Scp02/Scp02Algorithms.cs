using WSCT.GlobalPlatform.Security.Cryptography;

namespace WSCT.GlobalPlatform.Security.Scp02
{
    internal class Scp02Algorithms
    {
        public static byte[] GenerateCardCryptogram(byte[] sessionKey, byte[] cardChallenge, byte[] hostChallenge)
        {
            /*
				E.4.2.1
				The generation and verification of the card cryptogram is performed by concatenating the 8-byte host challenge, 2-
				byte Sequence Counter, and 6-byte card challenge resulting in a 16-byte block.
				Applying the same padding rules defined in appendix B.4 - DES Padding, the data shall be padded with a further 8-
				byte block ('80 00 00 00 00 00 00 00').
				The signature method, using the S-ENC session key and an ICV of binary zeroes, is applied across this 24-byte
				block and the resulting 8-byte signature is the card cryptogram.
			*/
            var message = new byte[24];
            Array.Copy(hostChallenge, 0, message, 0, 8);
            Array.Copy(cardChallenge, 0, message, 8, 8);
            Array.Copy(Constants.Padding, 0, message, 16, 8);

            return message
                .GenerateTripleDesMacCbc(sessionKey, Constants.ICV);
        }

        public static byte[] GenerateCMac(byte[] sessionKey, byte[] iv, byte[] message)
        {
            /*
				E.4.4
				A C-MAC is generated by an off-card entity and applied across the full APDU command being transmitted to the
				card including the header and the data field in the command message. It does not include Le.
				C-MAC generation and verification uses the Secure Channel C-MAC session key, an ICV and the signature method
				described in appendix B.1.2.2 - Single DES Plus Final Triple DES. (Prior to using the ICV, the ICV can be
				encrypted as described in appendix E.3.4 - ICV Encryption)
				The ICV is used to chain the commands for command sequence integrity; the initial value of the ICV is described in
				appendix E.3 - Cryptographic Algorithms. For any subsequent command following the first successful C-MAC
				verification, the ICV is the C-MAC value successfully verified for the previous command received by the card.
				The signature method, using the Secure Channel C-MAC session key and the ICV, is applied across the padded
				command message and the resulting 8-byte signature is the C-MAC. The rules for C-MAC padding are as defined in
				appendix B.4 - DES Padding.
			*/
            var lastMessageBlockLength = message.Length % 8;

            var mac = iv;

            if (message.Length / 8 > 0)
            {
                var desKey = sessionKey.AsSpan(0, 8).ToArray();

                mac = message.GenerateDesMacCbc(desKey, mac, 0, message.Length - lastMessageBlockLength);
            }

            mac = message.AsSpan(message.Length - lastMessageBlockLength, lastMessageBlockLength)
                .PadDataForDes()
                .GenerateTripleDesMacCbc(sessionKey, mac, 0, 8);

            return mac;
        }

        public static byte[] GenerateHostCryptogram(byte[] sessionKey, byte[] cardChallenge, byte[] hostChallenge)
        {
            /*
				E.4.2.2
				The generation and verification of the host cryptogram is performed by concatenating the 2-byte Sequence Counter,
				6-byte card challenge, and 8-byte host challenge resulting in a 16-byte block.
				Applying the same padding rules defined in appendix B.4 - DES Padding, the data shall be padded with a further 8-
				byte block ('80 00 00 00 00 00 00 00').
				The signature method, using the S-ENC session key and an ICV of binary zeroes, is applied across this 24-byte
				block and the resulting 8-byte signature is the host cryptogram	
			*/
            var message = new byte[24];
            Array.Copy(cardChallenge, 0, message, 0, 8);
            Array.Copy(hostChallenge, 0, message, 8, 8);
            Array.Copy(Constants.Padding, 0, message, 16, 8);

            return message
                .GenerateTripleDesMacCbc(sessionKey, Constants.ICV);
        }

        public static SessionKeys GenerateSessionKeys(Keys keys, byte[] sequenceCounter)
        {
            var enc = GenerateSessionKey(keys.Enc, Constants.EncDerivation, sequenceCounter);

            var cmac = GenerateSessionKey(keys.Mac, Constants.CMacDerivation, sequenceCounter);

            var rmac = GenerateSessionKey(keys.Mac, Constants.RMacDerivation, sequenceCounter);

            var dek = GenerateSessionKey(keys.Dek, Constants.DekDerivation, sequenceCounter);

            return new SessionKeys(cmac, rmac, enc, dek);
        }

        private static byte[] GenerateSessionKey(byte[] key, byte[] constant, byte[] sequenceCounter)
        {
            var DerivationData = new byte[16];
            Array.Copy(constant, 0, DerivationData, 0, 2);
            Array.Copy(sequenceCounter, 0, DerivationData, 2, 2);

            return DerivationData
                .EncryptTripleDesCbc(key, Constants.ICV);
        }
    }
}
