using WSCT.GlobalPlatform.Security.Cryptography;

namespace WSCT.GlobalPlatform.Security.Scp01
{
    internal class Scp01Algorithms
    {
        public static byte[] GenerateCardCryptogram(byte[] sessionKey, byte[] cardChallenge, byte[] hostChallenge)
        {
            /*
				D.3.2.1 Card Authentication Cryptogram
				The generation and verification of the card cryptogram is performed by concatenating the 8-byte host challenge and
				8-byte card challenge resulting in a 16-byte block.
				Applying the same padding rules defined in appendix B.4 - DES Padding, the data shall be padded with a further 8-
				byte block ('80 00 00 00 00 00 00 00').
				The signature method, using the S-ENC session key and an ICV of binary zeroes, is applied across this 24-byte
				block and the resulting 8-byte signature is the card cryptogram.		
			*/
            var message = new byte[24];
            Array.Copy(hostChallenge, 0, message, 0, 8);
            Array.Copy(cardChallenge, 0, message, 8, 8);
            Array.Copy(Constants.Padding, 0, message, 16, 8);

            return message
                .GenerateTripleDesMacCbc(sessionKey, Constants.ICV);
        }

        public static byte[] GenerateCMac(byte[] sessionKey, byte[] iv, byte[] message)
        {
            /*
				D.3.3
				A C-MAC is generated by an off-card entity and applied across the full APDU command being transmitted to the
				card including the header (5 bytes) and the data field in the command message. (It does not include Le.)
				Modification of the APDU command header and padding is required prior to the MAC operation being performed
                The signature method defined in appendix B.1.2.1 - Full Triple DES, using the MAC session key and the ICV, is
                across the padded data block and the resulting 8-byte signature is the C-MAC.
			*/
            var lastMessageBlockLength = message.Length % 8;

            var mac = iv;

            if (message.Length / 8 > 0)
            {
                mac = message.GenerateTripleDesMacCbc(sessionKey, mac, 0, message.Length - lastMessageBlockLength);
            }

            var finalBlocks = new byte[8];
            Array.Copy(message, message.Length - lastMessageBlockLength, finalBlocks, 0, lastMessageBlockLength);
            Array.Copy(Constants.Padding, 0, finalBlocks, lastMessageBlockLength, 8 - lastMessageBlockLength);

            mac = finalBlocks.GenerateTripleDesMacCbc(sessionKey, mac, 0, 8);

            return mac;
        }

        public static byte[] GenerateHostCryptogram(byte[] sessionKey, byte[] cardChallenge, byte[] hostChallenge)
        {
            /*
				D.3.2.2 Host Authentication Cryptogram
				The generation and verification of the host cryptogram is performed by concatenating the 8-byte card challenge and
				8-byte host challenge resulting in a 16-byte block.
				Applying the same padding rules defined in appendix B.4 - DES Padding, the data shall be padded with a further 8-
				byte block ('80 00 00 00 00 00 00 00').
				The signature method, using the S-ENC session key and an ICV of binary zeroes, is applied across this 24-byte
				block and the resulting 8-byte signature is the host cryptogram.				
			*/
            var message = new byte[24];
            Array.Copy(cardChallenge, 0, message, 0, 8);
            Array.Copy(hostChallenge, 0, message, 8, 8);
            Array.Copy(Constants.Padding, 0, message, 16, 8);

            return message
                .GenerateTripleDesMacCbc(sessionKey, Constants.ICV);
        }

        public static SessionKeys GenerateSessionKeys(Keys keys, byte[] cardChallenge, byte[] hostChallenge)
        {
            var enc = GenerateSessionKey(keys.Enc, cardChallenge, hostChallenge);

            var mac = GenerateSessionKey(keys.Mac, cardChallenge, hostChallenge);

            var dek = new byte[16];
            dek.AsSpan().CopyTo(keys.Dek);

            return new SessionKeys(mac, Array.Empty<byte>(), enc, dek);
        }

        private static byte[] GenerateSessionKey(byte[] key, byte[] cardChallenge, byte[] hostChallenge)
        {
            var derivationData = GenerateDerivationData(cardChallenge, hostChallenge);

            return derivationData
                .EncryptTripleDesEcb(key, Constants.ICV);
        }

        private static byte[] GenerateDerivationData(Span<byte> cardChallenge, Span<byte> hostChallenge)
        {
            var derivationData = new byte[16];
            var span = derivationData.AsSpan();

            cardChallenge[4..8].CopyTo(span);
            hostChallenge[0..4].CopyTo(span[4..8]);
            cardChallenge[0..4].CopyTo(span[8..12]);
            hostChallenge[4..8].CopyTo(span[12..16]);

            return derivationData;
        }
    }
}
